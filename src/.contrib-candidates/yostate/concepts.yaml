Стейт-машина: !concept
  Определение: |
    Алгоритм особой структуры, реагирующий на различные внешние события переходом из одного своего состояния в другое.
    Между вызовами стейт-машины её состояние можно сериализовать, записать в БД, а позже восстановить без потерь.
    Англ.: State Machine.
  Стейт-машина с сайд-эффектами: !example |
    Работа стейт-машины помимо перехода между Cостояниями, как правило, имеет сайд-эффекты: запись в файлы и БД,
    отправка сообщений по сети.
  Infinite state machine: !example |
    Не является конечной стейт-машиной (Finite State Machine). У машины ограничено количество не Cостояний, а их
    типов -- Классов состояний. Например, для типа Cостояния `/user-found/` возможны Cостояния с разным набором
    данных: 'name=Петя', 'name=Вася', и т.д.
  Многопользовательская стейт-машина: !example |
    Одна стейт-машина используется для взаимодействия с несколькими пользователями. У каждого пользователя своя
    отдельная сессия.
    Пример со стейт-машиной чат-бота. Пользователь общается с чат-ботом в личке, и тот помнит историю своего
    взаимодействия с каждым отдельным пользователем.
  Абстрактная базовая стейт-машина: !exclusion |
    Стейт-машины настолько отличаются друг от друга, что единый общий интерфейс для них вводить нет смысла.
  Стейт-машина рассыльщика в чат-боте: !extension |
    Чат-бот помимо обычного интеграктивного режима "запрос пользователя -- ответ" проводит также и рассылки по базе
    пользователей. У рассылок есть своя логика, реализованная также с помощью стейт-машины. Код её Состояний
    обрабатывает не сообщения от пользователей, а события внутри чат-бота: изменилась запись в БД, время вышло,
    администратор нажал на кнопку в админке.
  Составная стейт-машина: !extension |
    Стейт-машина может использовать сразу несколько роутеров -- первый использует Классы состояний из базы данных, а
    второй -- из кода.
  Разбитая по модулям стейт-машина: !example |
    Стейт-машина чат-бота такая большая и сложная, что её Классы состояний описаны в разных модулях Python.
  Собранная из сторонних библиотек стейт-машина: !extension |
    Стейт-машина чат-бота собрана как из самописных Классов стейтов, так и из готовых, импортированных из сторонних
    библиотек.
  Стейт-машина с предобработкой событий: !example |
    Если код внутри Классов состояний стейт-машины получается сложным и запутанным из-за неудобных в обработке событий,
    то в стейт-машину добавляется общая для всех Состояний логика нормализации и преобработки событий.
  Стейт-машина с контекстом исполнения: !example |
    Персональный чат-бот запускает стейт-машину, из любой точки которой доступен объект БД `Conversation` -- диалог
    с пользователем.
  Стейт-машина заливки данных на S3: !example |
    Заливка файлов в облако требует помнить историю взаимодействия с API: какая часть какого файла уже была залита на
    сервер, где они лежат. Для реализации такой логики удобно использовать стейт-машину.
  Синхронная стейт-машина: !example |
    Стейт-машина в ходе свой работы отправляет запросы по сети синхронным образом и предназначена для использования
    внутри программы с синхронным кодом.
  Асинхронная стейт-машина: !extension |
    Стейт-машина в ходе свой работы отправляет запросы по сети асинхронным образом и требует запуска event loop.
  Асинхронная стейт-машина для нестандартного event loop: !extension |
    Вместо стандартного event loop asyncio код стейт-машины требует экзотики: curio, trio, etc.
  Универсальная стейт-машина для синхронных и асинхронных программ: !extension |
    Библиотека предлагает универсальную стейт-машину для использования как в синхронных, так и асинхронных программах.
  Вложенные стейт-машины: !example |
    Стейт-машина потоковой обработки данных использует под капотом ещё один парсер, тоже реализованный в виде
    стейт-машины. Получается, что Состояние одной стейт-машины содержит id сессии или локатор к другой, скрытой внутри
    стейт-машины.


Класс состояний: !concept
  Определение: |
    Шаблон однотипных Состояний, имеющих общую схему параметров и общий код реакции на события.
    Стейт-машина использует Классы состояний как шаблон для создания новых Состояний в процессе своей работы.
    Класс состояния содержит в себе код для Краулера -- инструкции, которые надо исполннить в ответ на происходящие
    события.
    Англ.: State Class.
  Стартовый класс состояний: !example |
    Класс состояний может являться стартовой точкой — отсюда начинает свою работу конечный автомат.
  Базовый класс состояний: !example |
    Все Классы состояний реализуют единый набор атрибутов и методов -- интерфейс класса состояний.
    Базовый класс не является абстрактным. Его можно использовать в качестве "пустого" состояния, проглатывающего все
    события без реакции -- такой себе аналог `/dev/null` в Linux.
    Также базовый класс можно декорировать, используя его в качестве болванки.
  Класс состояний без параметров: !example
  Класс состояний со схемой параметров: !example
  Класс состояний с параметрами, но без схемы: !exclusion |
    Микрофреймворк Yostate сопротивляется созданию состояний без определённой схемы параметров и не предлагает
    никаких инструментов на такой случай.
  Реиспользуемый класс состояний: !example |
    Класс состояний импортируется из сторонней библиотеки. Код внутри класса не знает заранее в каком приложении и
    какой стейт-машиной будет запущен. Но он знает тип стейт-машины, на которую рассчитан.
  Синхронный класс состояний: !example |
    Код внутри класса состояний в ходе свой работы отправляет запросы по сети синхронным образом. Такой код
    предназначен для использования внутри программы с синхронным кодом.
  Асинхронный класс состояний: !example |
    Код внутри класса состояний в ходе свой работы отправляет запросы по сети асинхронным образом и требует запуска
    event loop.
  Асинхронный класс состояний для нестандартного event loop: !example |
    Вместо стандартного event loop asyncio код класса состояний требует экзотики: curio, trio, etc.
  Универсальный класс состояний для синхронного и асинхронного краулера: !example |
    Сторонняя библиотека предлагает универсальный класс состояний, которым можно пользоваться и в синхронной и в
    асинхронной стейт-машине.
  Класс состояний с логикой инициализации и деинициализации: !example |
    Кнопочный чат-бот сначала отправляет пользователю сообщение с кнопками и просит того сделать выбор, а после ввода
    деактивирует либо прячет старые кнопки. Чтобы менять кнопки стейт-машина запускает код управления клавиатурой при
    каждом переходе из одного состояния в другое -- на входе и на выходе из Состояния.
  Класс состояний с автопереходом без события: !example |
    В процессе разработки программист принудительно переводит бота из одного Состояния в другое, не дожидаясь
    какого-либо внешнего события: Update объекта от Tg и/или события в БД. Также администратор в админке принудительно
    переводит бота из одного Состояния в другое по просьбе пользователя.


Состояние: !concept
  Определение: |
    Одно из множества возможных состояний стейт-машины. Определяет то, как стейт-машина будет реагировать на
    последующие события.
    Состояние обязательно сериализуемо, чтобы не мешать сериализации стейт-машины целиком.
    Англ.: State.
  Состояние с параметрами: !example |
    Состояние включает в себя набор специфических для этого Состояния параметров. Например, Состояние
    "оформление заказа" может содержать два параметра:
    ```python
    items: list[Item]
    delivery_address: str
    ```
    По мере того, как пользователь Tg-бота наполняет свою корзину заказа стейт-машина переходит из одного Состояния
    "оформление заказа" в другое похожее, отличающееся только параметрами `items` и `delivery_address`.
  Два одинаковых состояния: !example |
    Чат-бот находится в Состоянии `/start/` и предлагает пользователю выбрать пункт меню. Тут пользователь повторно
    вводит команду `/start` и ожидает получить от чат-бота новое такое же сообщение с выбором пункта меню. Получается,
    что конечное Состояние не отличается от начального, но при этом код отрабатал так, словно произошли выход из
    Состояния и повторный вход.
  Мутирующее состояние: !exclusion
    Состояние не может менять свои параметры. Единственный способ изменить состояние стейт-машины -- это перевести
    Краулер из одного Состояния в другое. Такое ограничение введено, чтобы Краулер и стейт-машина всегда надёжно
    отслеживали любые изменения состояния.


Декоратор класса состояний: !concept
  Определение: |
    Декоратор превращает один Класс состояний в новый Класс состояний с расширенной логикой.
  Декоратор редиректа по команде пользователя: !example |
    Пользователь ввёл команду /start -- декоратор отреагировал переводом стейт-машины в состояние `/start/`.
  Декоратор отправки сообщения: !example |
    При переходе стейт-машины в новое состояние декоратор отправляет пользователю текстовое сообщение с клавиатурой и
    предложением сделать выбор. На выходе из состояния декоратор меняет сообщение в чате Telegram, чтобы спрятать
    клавиатуру.
  Синхронный декоратор класса состояний: !example |
    Код внутри декорактора класса состояний в ходе свой работы отправляет запросы по сети синхронным образом. Такой код
    предназначен для использования внутри программы с синхронным кодом.
  Асинхронный декоратор класса состояний: !example |
    Код внутри декоратора класса состояний в ходе свой работы отправляет запросы по сети асинхронным образом и требует
    запуска event loop.
  Асинхронный декоратор класса состояний для нестандартного event loop: !example |
    Вместо стандартного event loop asyncio код декоратора класса состояний требует экзотики: curio, trio, etc.
  Универсальный декоратор для синхронного и асинхронного краулера: !example
    Сторонняя библиотека предлагает универсальный декоратор класса состояний, которым можно пользоваться и
    в синхронной и в асинхронной стейт-машине.


Локатор класса состояний: !concept
  Описание: |
    Локатор класса состояний -- это аналог адреса сайта или пути к файлу, только для Классов состояний. Локатор класса
    состояний позволяет найти Класс состояний среди известных Маршрутов Роутера.
  Локатор класса состояний для профиля пользователя: !example |
    В стейт-машине чат-бота может существовать Класс состояний `UserProfile`. Локатор класса состояний может выглядеть
    как `/user/profile/`.
  Параметризованный локатор класса состояний: !exclusion |
    Локатор класса состояний не может содержать внутри себя данные, подобно url `/user/:username:/`. Параметры
    нужны для описания Состояния, но не для поиска Класса состояний.
  Корневой локатор: !example |
    По аналогии с файловой системой и URL-адресами стандартным Локатором класса состояний для точки старта можно
    указать слэш `/`.
  Локатор без стартового слэша: !example |
    На проекте действует соглашение, согласно которому Локатор класса состояния записывается строго без стартового
    слэша.
  Локатор без завершающего слэша: !example |
    На проекте действует соглашение, согласно которому Локатор класса состояния записывается строго без завершающего
    слэша.
  Локатор с пробельными символами: !example |
    На проекте действует соглашение, согласно которому Локатор класса состояния записывается с пробелами между словами.
  Локатор с символами верхнего регистра: !example |
    На проекте действует соглашение, согласно которому Локатор класса состояния записывается в CamelCase нотации.
  Юникод: !example |
    Локатор класса состояния может помимо ASCII-символов содержать кириллицу, китайские иероглифы и даже эльфийский
    текст.
    Эта возможность полезна для стейт-машин чат-ботов с интерфейсом, настраиваемым через админку. В таком случае
    локаторы придумывает и задаёт через БД администратор чат-бота. Делает он это на своём родном языке.


Локатор состояния: !concept
  Описание: |
    Локатор -- это аналог адреса сайта, только для Состояний. Состоит из двух частей: Локатора класса состояний и
    параметров состояния.
    Локатор состояния используется для того, чтобы восстановить положение Краулера стейт-машины или переместить
    Краулер в новое Состояние.
  Локатор в виде IRI: !extension |
    IRI -- это аналог URL с поддержкой Unicode-символов.
    Пример локатора: `yostate://main-menu/`, где:
      - `yostate` -- название протокола;
      - `/main-menu/` -- задаёт адрес класса состояний.
    Локатор в формате IRI записывается одной строкой текста, что удобно для быстрого копирования и вставки.
  Локатор состояния без локатора класса состояний: !exclusion |
    Локатор состония может не иметь параметров, но обязан содержать в себе Локатор класса состояний.
  Локатор с параметрами: !example
  Локатор без параметров: !example
  Локатор с вложенными параметрами: !example
  Локатор с кириллицей в параметрах: !example
  Локатор с unicode-символами в параметрах: !example
  Локатор с кириллицей в адресе класса состояния: !example
  Локатор с unicode-символами в адресе класса состояния: !example
  Относительный локатор: !example
  Локатор с лишними параметрами: !example |
    Стейт использует не все параметры, указанные в локаторе.
  Frozen Locator: !example |
    Локатора запрещает изменение своих атрибутов. Такое бывает полезно для кэширования, когда локатор вычисляется для
    какого-то набора данных и не должен меняться до тех пор, пока неизменны исходные данные.


Роутер: !concept
  Определение: |
    Обеспечивает связь между различными состояниями. Позволяет Краулеру, находясь в одном Состоянии найти по Локатору
    соответствующий другой Класс состояний, создать Состояние и перейти в него.
    Англ.: Router (en).
  Роутер с автоматической декорацией: !example |
    Каждый класс состояний при регистрации в роутере автоматически оборачивается декоратором в новый класс с
    дополнительной логикой.
  Динамический роутер: !extension |
    Роутер хранит свои маршруты в базе данных. Маршруты меняются налету без перезапуска чат-бота.
  Абстрактный роутер: !extension |
    Роутер много разных, но все они реализуют единый общий интерфейс абстрактного роутера. Такой интерфейс позволяет
    Краулеру перемещаться по Состояниям, не обращая внимания на особенности роутера и места хранения маршрутов.
  Композитный роутер: !extension |
    Через один роутер можно добраться до маршрутов сразу из нескольких разных источников: часть машрутов описаны в коде,
    часть -- в базе данных, а часть -- генерируется кодом на лету.
  Вложенный роутер: !exclusion |
    Роутеры запрещено вкладывать один в другой матрёшкой подобно тому, как веб-фреймворки предлагают составлять общую
    схему урлов проекта из нескольких схем поменьше.
    Такой запрет призван решить несколько проблем:

    Из-за вложенных роутеров с префиксами в адресах стейтам сложнее станет находить следующий Локатор класса
    состояния для перехода краулера в следующее Сосстояние. Понадобится дополнительный механизм реверса урлов, глобально
    доступный единственный на проект роутер и механизм с пространствами имён для роутов.

    Корневой и вложенный роутеры смогут иметь разные настройки валидации и нормализации урлов, из-за чего
    начнётся путаница с адресами.

    Корневой и вложенный роутеры смогут, также, иметь разный набор несовместимых декораторов классов
    состояний.

    Всех этих проблем можно избежать, если вместо вложенных роутеров явным образом импортировать и регистрировать в
    роутере нужные классы состояний. Для реверса локаторов внутри импортированных классов состояний можно использовать
    контекст -- через contextvar предоставить схему отображения "Название --> Локатор класса состояния"
  Роутер с валидацией локатора: !example |
    На проекте действует соглашение, согласно которому Локатор класса состояния записывается в формате
    UPPER-CASE-WITH-DASHES -- в верхнем регистре и cо знаком тире вместо разделителя. Если программист забывает об этом
    правиле, то роутер ругается при попытке зарегистрировать Локатор класса состояния, нарушающий соглашение.
  Роутер с нормализацией локатора: !example |
    На проекте действует соглашение, согласно которому Локатор класса состояния всегда должен завершаться слэшом `/`.
    Если слэш пропущен, то роутер сам его дописывает -- нормализует.
  Роутер с ASCII локаторами: !example |
    На проекте действует соглашение, согласно которому Локатор класса состояния может содержать только ASCII-символы.
  Роутер с импортированными классами состояний: !example |
    Часть зарегистрированных в роутере Классов состояний импортированы из сторонних библиотек. Локатор каждого
    класса состояния выбирает прикладной программист, а не мейнтейнер либы.


Маршрут: !concept
  Определение: |
    Маршрут задаёт правило для поиска класса состояний по известному локатору, а точнее по его части -- `path`.
    Как правило, маршрут описывается в виде строки, похожей на путь файловой системы и на одноимённую часть URL (path),
    например, `/menu/order_form/confirmation/`.
    Англ.: Route
  Два маршрута для одного класса состояний: !example |
    Один класс состояний доступен сразу по нескольким разным маршрутам. Такое возможно, если важна обратная
    совместимость со старыми локаторами в БД.
  Маршрут с подсказкой: !example |
    К маршруту прикреплено текстовое описание для программиста.


Событие: !concept
  Определение: |
    Событие приводит к запуску стейт-машины и может перевести её в новое состояние.
    Англ.: Event
  Пришло сообщение от пользователя чат-бота: !example |
    От пользователя чат-бота прилетело новое текстовое сообщение. Стейт-машина воспринимает это как событие,
    требующее обработки.
  Пользователь чат-бота Tg ввёл команду: !example |
    Пользователь прислал в сообщении команду /start или что-то подобное. Бот замечает команду, его стейт-машина
    реагирует на событие.
  Поступила новая порция данных: !example |
    Стейт-машина занимается парсингом бинарного формата данных.  на обработку новой порции байтов.
  Прилетел HTTP запрос: !example |
    У чат-бота может быть своё веб-API, например, для интеграции с платёжной системой или HTML-формами лендингов.
    Тогда, входящие HTTP запросы будут переводить стейт-машину из одного состояния в другое. Получается, что бот
    реагирует на такие HTTP запросы как на события.
  Сработал таймер: !example |
    Стейт-машина отвечает за рассылку по целой базе пользователей. Она включается не через вебхук, а по таймеру.
  Клик по кнопке в админке: !example |
    Администратор чат-бота нажал на кнопку в админке, чтобы отправить пользователю сообщение. Клик по кнопке
    приводит к запуску стейт-машины чат-бота.
  # TODO Не хватает примеров !exclusion, а то получается, что событием может быть что угодно.


Краулер: !concept
  Определение: |
    Краулер -- это нечто, что перемещается по состояниям стейт-машины. Удобно представлять краулер в виде паука,
    перемещающегося по паутине Состояний стейт-машины.
    Англ.: Crawler.
  Прерванный краулер: !example |
    Стейт-машина занимается потоковым парсингом данных. Поступление свежей порции данных -- это то событие, которое
    должен обработать код стейта. Если в процессе обработки данных стейт обнаруживает, что поступившей порции данных
    ему не хватает для завершения работы, то он выкидывает исключение. Таким образом стейт сообщает стейт-машине, что
    ожидает поступления новой порции данных.
  Кастомный краулер: !exclusion |
    Все стейт-машины разные, но все они обязаны использовать единый универсальный краулер Yostate. Это ограничение
    позволяет придерживать единого набора концепций и подходов в разработке стейт-машин.
  Отсоединённый краулер: !example |
    Краулер уже создан и инициализирован, но ещё не прикреплён в какому-либо состоянию стейт-машины.
    Такая ситуация бывает, когда не удалось восстановить старое состояние краулера.
  Синхронный краулер: !example
  Асинхронный краулер: !extension
  Асинхронный краулер для нестандартного event loop: !extension
  Смешанный синхронно-асинхронный краулер: !exclusion |
    Стейт-машина должна явно указать какой тип краулера она собирается использовать: синхронный или асинхронный.
    Синхронный краулер будет использовать в классах состояний только синхронный код, а асинхронный краулер -- только
    асинхронный.

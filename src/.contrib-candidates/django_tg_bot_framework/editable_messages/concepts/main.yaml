Сообщение: !concept
  Определение: |
    Готовый к отправке в телеграм объект.
  Текстовое сообщение: !example
  Бинарное сообщение: !example |
    Сообщение с картинкой, фотографией, фотогалереей, документом.
  Markdown сообщение: !example |
    Текстовое сообщение отформатировано в Markdown
  HTML сообщение: !example
    Текстовое сообщение отформатировано в HTML
  Встроенное в серию сообщение: !example |
    Сообщение привязано к серии сообщений и имеет в этой серии порядковый номер.
  Не встроенное в серию сообщение: !exclusion |
    Сообщение, не привязанное к серии не может быть отправлено, потому что оказывается не привязанным ни к одному локатору серии.
  Встроенное в несколько серий сообщение: !exclusion |
    Если в нескольких сериях используется одинаковое сообщение, то для каждой серии создаем копию этого сообщения.
    Это приведет к созданию копий в БД, но позволит упростить интерфейс для КМ и уменьшит запутанность контента.
  Мультиязычное сообщение: !exclusion |
    Сообщение может быть привязано только к одной серии. А в серии определен только один язык.
  Не завязанное на конкретном языке сообщение: !exclusion |
    Если контент сообщения не зависит от языка, но в боте используется мультиязычность, то для каждого языка создаем копию сообщения.
    Потому что сообщение может быть привязано только к одной серии. А в серии определен только один язык.
    Это приведет к созданию копий в БД, но позволит упростить интерфейс для КМ и уменьшит запутанность контента.


Серия сообщений: !concept
  Определение: |
    Упорядоченный набор сообщений с одинаковым языком. Все сообщения отправляются друг за другом без задержки.
  Серия сообщений со смешанным контентом: !example |
    Контент-менеджер хочет отправить смешанный контент, включающий и текст, и картинки.
  Упорядоченная серия сообщений: !example |
    Порядок сообщений важен, его задаёт контент-менеджер.
  Серия с требуемыми кнопками: !example |
    В серии сообщений присутствуют все кнопки, требуемые контрактом
  Серия с не обязательными кнопками: !example |
    В серии сообщений присутствуют кнопки, которые не указаны в контракте
  Серия соответствует состоянию стейт-машины: !example |
    Отправка серии происходит из определенного состояния.
  Серия, отправляемая не из состояния: !example |
    Отправка возможна из любого места кода
  Одна серия привязана к нескольким состояниям стейт-машины: !exclusion |
    Если так получилось, что одна серия должна отправляться из нескольких состояниям, то либо в БД создаём отдельную
    серию для каждого состояния, считаем их разными, либо перенаправляем пользователя в другое состояние, откуда будет
    отправлена нужная серия.
  К одному состоянию стейт-машины привязано несколько серий: !example |
    Из одного состояния могут отправляться разные серии сообщений в зависимости от контекста. Например состояние
    "Результат оплаты заказа" может отправлять сообщение о том, что оплата прошла успешно или не успешно.
  Серия сообщений для разовой рассылки: !example
  Серия сообщений для триггерной рассылки: !example
  Серия содержит сообщения на разных языках: !exclusion
  Серия без указания языка: !exclusion |
    Серия без языка не будет использована в работе бота.
  Серия-черновик: !example |
    Контент сообщений в серии ещё не прошел редактуру и не готов к использованию.
  Опубликованная серия: !example |
    Контент-менеджер проверил сообщения и разрешил отправлять их пользователям.
  Серия без локатора: !exclusion |
    Серия привязана к локатору серии. Этот локатор используется для поиска серии в БД.
  Одна серия привязана к нескольким локаторам серий: !exclusion |
    Если так получилось, что одна серия должна соответствовать нескольким локаторам серий, то в БД создаём
    отдельную серию для каждого локатора, считаем их разными.
    Это приведёт к созданию копий в БД, но зато уменьшит запутанность в работе контент менеджера и сохранит гибкость.
  Выгруженная серия: !example |
    Серию сообщений ещё не успели загрузить в CMS, и она существует в виде отдельного текстового файла.
    Такой файл подходит для хранения в репозитории кода. Этот файл можно загрузить в CMS или выгрузить оттуда.
    Бинарный контент выгружается по желанию пользователя в виде b64


Шаблон сообщения: !concept
  Определение: Хранящийся в Источнике данных объект, необходимый для подготовки Сообщения.
  Шаблон для текстового сообщения: !example
  Шаблон для сообщения с изображением: !example
  Шаблон для сообщения с документом: !example
  Выгруженный шаблон сообщения: !example |
    Шаблоны сообщений вместе с контентом можно выгрузить из одного Источника данных и залить в другой.
  Ломающий шаблонизатор шаблон сообщения: !exclusion |
    Текст шаблона содержит символы, ломающие шаблонизатор. Запретить!


Локатор серии сообщений: !concept
  Описание: |
    Локатор серии сообщений -- это аналог адреса сайта или пути к файлу, только для Серий сообщений. Локатор позволяет найти серию
    среди известных Маршрутов Роутера.
  Параметризованный локатор серии сообщений: !exclusion |
    Локатор класса состояний не может содержать внутри себя данные, подобно url `/user/:username:/`.
  Корневой локатор: !example |
    По аналогии с файловой системой и URL-адресами стандартным Локатор серии сообщений для точки старта можно
    указать слэш `/`.
  Юникод: !example |
    Локатор серии сообщений может помимо ASCII-символов содержать кириллицу, китайские иероглифы и даже эльфийский
    текст.
    Эта возможность полезна для стейт-машин чат-ботов с интерфейсом, настраиваемым через админку. В таком случае
    локаторы придумывает и задаёт через БД администратор чат-бота. Делает он это на своём родном языке.
  Локатор серии соответствует локатору состояния: !example |
    Серия сообщения отправляется из определенного состояния бота, поэтому на проекте действует соглашение, согласно которому
    Локатор серии сообщений по возможности идентичен Локатору состояния.
  Составной локатор: !example |
    Локатор серии состоит из 2 частей: name_space и name. У серий относящихся к одному состоянию должны иметь одинаковые
    name_space и разные name.


Контракт серии сообщений: !concept
  Определение: |
    Перечисление того, какие текстовки, картинки и прочий контент необходим в данном состоянии.
  Суть сообщения: !example |
    Для серии в контракте указан не только локатор и прочие данные, но и сформулирована ключевая мысль,
    чтобы и программист и контент-менеджеры понимали о чём здесь речь, пока не готова текстовка.
  Плейсхолдер: !example |
    Плейсхолдер может использоваться рендерером, в случае, если не удалось найти нужные Шаблоны сообщений
    в Источнике данных
  Язык сообщения: !example |
    В контракте могут быть ограничены языки, в которых сообщение должно отправляться
  Требуемые кнопки: !example |
    Для сообщения требуется набор определенных кнопок с заданными callback_data
  Схема контекста: !example |
    В контракте указаны переменные контекста, котрые могут быть испольованы при рендере
  Локализованная суть сообщений: !exclusion |
    Нет смысла переводить ключевую мысль на разные языки. Считаем, что и контент-менеджеры и программисты могут
    общаться на одном общем языке. На этом общем языке и формулируется суть сообщений.
  Фиксируемые типы сообщений в серии: !exclusion |
    Требование относится к серии в целом и не регламентирует конкретный тип сообщений в этой серии


Схема сообщений: !concept
  Определение: |
    Схема сообщений — это аналог контракта между программистами и контент-менеджерами. Она описывает все требуемые
    для работы бота серии сообщений. Это совокупность всех series requirement.
  Схема триггерных рассылок: !example |
    Для триггерных рассылок может быть создана отдельная схема сообщений, на которые завязан код чат-бота.
  Реализованная схема: !example |
    В схеме есть полный набор опубликованных сообщений, чтобы соответствовать минимальным требованиям.
  Нереализованная схема: !example |
    Сообщения в БД CMS не полностью соответствуют заявленной схеме: не хватает сообщений, кнопок в клавиатуре или схема контекста
    устарела.
  Защищённая схема: !example |
    CMS внимательно следит за тем, чтобы контент-менеджер случайно не нарушил правила, заданные программистами для корректной
    работы кода.
  Схема без кода: !extension |
    Ещё на этапе проектирования чат-бота до написания кода продукт менеджер зафиксировал схемы сообщений бота и даже написал
    сообщения, чтобы использовать их в качестве ТЗ для программистов.
  Выгруженная схема: !extension |
    Схемы сообщений ещё не успели загрузить в CMS, и она существует в виде отдельного текстового файла. Такой файл подходит для
    хранения в репозитории кода. Этот файл можно загрузить в CMS или выгрузить оттуда.
  Автогенерённая схема: !extension |
    Схема сообщений создана автоматически по py-коду уже написанного телеграм-бота.
  Несколько схем в одной CMS: !extension |
    В одной CMS одновременно могут существовать и поддерживаться в рабочем состоянии несколько схем сообщений. Например, одна схема
    может использоваться здесь и сейчас, а вторая — готовиться к обновлённой версии ПО на сервере.
  Схема с обязательными кнопками: !example |
    В схеме помимо контента сообщений регламентируются и кнопки.


Роутер серий сообщений: !concept
  Определение: |
    Позволяет найти серию сообщения по Локатору серии.
  Роутер серий сообщений с автоматическим парсингом роутера состояний: !example |
    Нет необходимости отдельно регистрировать состояния в двух роутерах. Роутер серий сообщений может сам распарсить роутер состояний
    и получить информацию о том, какие серии сообщений нужны какому состоянию и собрать из этого Схему сообщений.
    При этом Роутер состояний может быть в нескольких файлах
  Динамический роутер: !extension |
    Роутер серий сообщений может налету получать информацию из динамического роутера состояний, если в том произошли
    изменения.
  Роутер с валидацией локатора: !example |
    Роутер проверяет Локаторы серий сообщений на соответствие требований наименования.
  Роутер с нормализацией локатора: !example |
    На проекте действует соглашение, согласно которому Локатор серии сообщений всегда должен завершаться слэшом `/`.
    Если слэш пропущен, то роутер сам его дописывает -- нормализует.


Шаблонизатор: !concept
  Определение: |
    Шаблонизатор берет Шаблон текстового сообщения с переменными и подставляет в него актуальные дынные из Контекста рендеринга.
  Не текстовый шаблонизатор: !exclusion |
    Шаблонизатор работает только с текстовыми сообщениями.
  Шаблонизатор меняет количество сообщений в серии: !exclusion
  Конвертирующий шаблонизатор: !example |
    Шаблонизатор может принимать различные не бинарные типы данных и конвертировать их в текстовые.
  Ограничивающий шаблонизатор: !extension |
    Сообщение может превысить лимит Telegram на максимальный размер сообщения после рендеринга. В таком случае
    у КМ есть возможность ограничить количество символов вставляемых в переменную. Например с помощью тегов
  Альтернативный шаблонизатор: !extension |
    Стандартный шаблонизатор может не устраивать владельца бота. Например владелец захочет, чтобы шаблонизатор учитывал
    падежи и прочую грамматику. В таком случае он может руками нанятого программиста заменить стандартный шаблонизатор.
    Потянет за собой и альтернативный виджет в админке.
  Асинхронный шаблонизатор: !exclusion |
    Подразумевается, что шаблонизатор к моменту запуска уже имеет все необходимые данные для работы.
    Поэтому блокирующих запросов в нем быть не должно. Асинхрон ему в работе никак не поможет.
    Однако это не касается альтернативных шаблонизаторов.
  Bulk-шаблонизатор: !exclusion |
    Шаблонизатор обрабатывает одно сообщение за раз.
  Мультиязычный шаблонизатор: !example |
    Шаблонизатор может адаптировать формат дат и чисел под разные языки.


Контекст рендеринга: !concept
  Определение: |
    Контекст общения с пользователем. Хранит в себе актуальные данные текущего диалога, которые рендерер вставляет в шаблоны сообщений:
    имя пользователя, товары в корзине, заполненные поля анкеты и т.д. Контекст состоит из переменных, которые вставляются в шаблон.
  Отдельный контекст для каждого сообщения в серии: !exclusion |
    Контекст рендеринга относится ко всей серии, а не к отдельным сообщениям. Чтобы не усложнять структуру контекста.
    К тому же могут быть различия в разных языках - какие переменные использовать в каких сообщениях серии.
  Разный контекст для разных языков: !exclusion |
    Если для разных языков требуется разный набор данных, то делаем максимально широкий набор переменных контекста.
    Лишние для данного языка переменные при рендере будут проигнорированы.
  Изменяемый контекст: !example |
    В течение диалога контекст постоянно актуализируется.
  Бинарный контекст: !exclusion |
    Контекст нужен для работы шаблонизатора. Шаблонизатор работает только с текстовыми сообщениями.
  Не текстовый контекст: !example |
    Контекст может содержать любые не бинарные данные, которые можно конвертировать в текст: числа, даты, None и т.д.


Рендерер: !concept
  Определение: |
    Рендерер - главный движок всего приложения. Именно он вызывается из Состояния, чтобы получить готовые к отправке
    сообщения. Рендерер собирает все необходимые данные и подготавливает request:
    1. Берет Требование к серии сообщений.
    2. Берет текущий язык из Convesation.
    3. Если сообщение текстовое, то скармливает сообщения Шаблонизатору
    4. Формирует готовую Серию реквестов.
  Использует плейсхолдер: !example |
    Рендерер не находит данные в источнике и использует плейсхолдер.
  Мок рендерер: !extension |
    Всегда использует плейсхолдер.
  Кеширующий рендерер: !extension |
    Серии сообщений меняются в БД гораздо реже, чем отправляются. Рендерер может кешировать серии, чтобы сократить количество запросов к БД.
  Пустое сообщение: !example |
    После подстановки переменных в шаблон сообщение оказалось пустым -- там нет ничего, кроме пробелов.
    При этом, если к сообщению прикреплены кнопки, то они должны отправиться.
  Рендер клавиатур: !extension
  Удаление и правка ин-лайн клавиатур: !exclusion
  Разные источники данных: !exclusion |
    Рендерер работает только с БД. Работа с разными источниками данных сильно усложнит проверку целостности схемы сообщений и не принесет ощутимых преимуществ.


Виджет: !concept
  Синонимы: Редактор сообщений
  Определение: |
    Виджет на фронтенде, позволяющий КМ редактировать текстовки сообщений.
  Виджет с подсветкой синтаксиса: !extension |
    Подсветка синтаксиса MD и HTML облегчит работу КМ.
  Виджет с пред-просмотром: !extension |
    Виджет позволяет сразу увидеть как сообщение будет отображаться в ТГ.
  Кастомный виджет: !extension |
    В чат-бота добавлен особый тип редактируемых сообщений, который не поддерживается фреймворком и библиотекой tg_api, но прикладной
    код знает как с ними работать. В админке для такого типа сообщений предусмотрен свой особый тип виджета, упрощающий жизнь
    контент-менеджеру.
